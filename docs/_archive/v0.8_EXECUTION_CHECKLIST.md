# v0.8 Execution Checklist — Serviceability (Deflection + Crack Width)

**Status:** ✅ Completed in v0.8.0 (kept as a historical checklist).

**Goal (v0.8 Level A):** add deterministic, auditable serviceability checks to the library (Python + VBA parity), with tests and docs updates.

**Related backlog item:** `TASK-041` in `docs/TASKS.md`.

**Important compliance note:** IS code clause text and numeric tables are copyrighted. This checklist avoids reproducing clause text; implement numeric limits as parameters/config and reference clause IDs in docs.

---

## 0) Non‑negotiables

- Deterministic outputs (same inputs → same results).
- Units must be explicit and consistent.
- No silent defaults: if a value is assumed, the output must say so.
- Keep core math separate from UI/I-O.
- Maintain Python/VBA parity for Level A checks.
- Add/extend Python tests for every behavior change.

---

## 1) Scope lock (Level A)

### 1.1 Deflection (Level A)

- Use the span/depth ratio method.
- Support condition categories (at minimum): `cantilever`, `simply_supported`, `continuous`.
- Modification factor approach:
  - tension steel factor (based on steel ratio/provided steel)
  - compression steel factor (if Asc provided)
  - flanged factor (if beam is T/L; optional for Level A if already supported elsewhere)

**Output must include:**
- computed governing ratio (e.g., L/d)
- allowable ratio (after modifiers)
- pass/fail and a concise reason string
- explicit list of which modifiers were applied and what inputs drove them

### 1.2 Crack width (Level A)

- Exposure-driven limit (e.g., mild/moderate/severe/very severe).
- A deterministic calculation path that produces a crack width estimate and compares against the configured limit.

**Output must include:**
- computed crack width value
- limit used (and exposure class)
- pass/fail and a concise reason string
- explicit list of assumptions (especially if service steel stress is estimated)

### 1.3 Out of scope (v0.8 Level A)

- Full Annex-C style long-term deflection (creep/shrinkage) unless you explicitly decide to include it.
- Load-combination generation from unfactored actions.
- Optimizer/BBS features.

---

## 2) Contracts (types + API shape)

### 2.1 Python contracts

Create new module and types:

- [x] Add `Python/structural_lib/serviceability.py`
- [x] Add result types to `Python/structural_lib/types.py`:
  - `DeflectionResult`
  - `CrackWidthResult`
  - (Optional) `ServiceabilityResult` wrapper containing both

Recommended result fields (minimum):
- `is_ok: bool`
- `remarks: str`
- `inputs: Dict[str, float|str]` (or explicit fields)
- `assumptions: List[str]`
- `computed: Dict[str, float|str]` (e.g., `ld_ratio`, `allowable_ld`, `wcr_mm`, `wlim_mm`)

### 2.2 VBA contracts

- [x] Add a new module (suggested): `VBA/Modules/M17_Serviceability.bas`
- [x] Add UDTs mirroring Python (names can differ, fields should map cleanly).
- [ ] Decide whether to expose as worksheet UDFs via `M09_UDFs.bas` (optional, but recommended for Excel users).

---

## 3) Inputs and unit conventions

### 3.1 Inputs (recommended minimal set)

Deflection:
- span (mm)
- effective depth d (mm)
- section width b (mm) (if needed for steel ratio)
- Ast provided or required (mm²)
- Asc (mm², optional)
- support condition enum/string
- fck (N/mm²), fy (N/mm²) (if needed for modifiers)

Crack width:
- cover (mm)
- bar diameter (mm)
- bar spacing (mm)
- steel stress at service (N/mm²) OR a clearly-documented estimation path
- exposure class enum

### 3.2 Unit rules

- Geometry: mm
- Stresses: N/mm²
- Crack width: mm

If you accept kN or kN·m anywhere in serviceability, convert at the edge and store the unit in outputs.

---

## 4) Implementation steps (Python first)

### 4.1 Build the Python module

- [ ] Implement `check_deflection_span_depth(...) -> DeflectionResult`
  - [ ] Validate inputs (positive span/d; reasonable bounds)
  - [ ] Compute governing ratio
  - [ ] Apply configured basic limits + modifiers
  - [ ] Return pass/fail with explicit assumptions

- [ ] Implement `check_crack_width(...) -> CrackWidthResult`
  - [ ] Validate inputs (cover/spacing/diameter)
  - [ ] Compute crack width and compare to configured exposure limit
  - [ ] Return pass/fail with explicit assumptions

- [ ] Add small helper enums/types if needed (e.g., `ExposureClass`, `SupportCondition`).

### 4.2 Tests (Python)

Add tests under `Python/tests/`:

- [ ] Boundary tests around deflection threshold transitions (e.g., when allowable L/d changes due to modifiers)
- [ ] Determinism tests (same inputs produce identical outputs)
- [ ] Guardrail tests for invalid geometry/inputs (should fail gracefully with `is_ok=False` and a clear `remarks`)
- [ ] Crack width tests around exposure limit boundaries

**Test style guidance:**
- Prefer “threshold” assertions (pass/fail + key computed fields) over matching long floating point chains.
- Use tolerances where floats are involved.

### 4.3 Docs (Python)

- [ ] Update `docs/reference/api.md` with serviceability API and units.
- [ ] Update `docs/reference/known-pitfalls.md` with serviceability-specific unit traps/assumption traps.

---

## 5) VBA parity steps

- [ ] Port Level A formulas into `M17_Serviceability.bas`
- [ ] Mirror input validation (fail with a reason rather than crashing)
- [ ] If exposing as UDFs: add wrappers in `M09_UDFs.bas`
- [ ] Update `docs/contributing/vba-guide.md` to list the new entry points

**Parity checklist:**
- same limits/config values
- same rounding policy (keep full precision internally)
- same pass/fail for benchmark vectors

---

## 6) Integration touch points (defer until core is stable)

Only after core checks are stable and tested:

- [ ] Add optional serviceability fields/columns to the Excel design output (if desired)
- [ ] Wire into `M11_AppLayer.bas` and/or reporting once the API is stable

Keep the first integration minimal: add a serviceability summary (pass/fail + key governing value + remarks).

---

## 7) Acceptance criteria (Definition of Done)

- [ ] Python: serviceability module exists and is documented in API reference
- [ ] Python: new tests added and passing
- [ ] VBA: Level A parity module exists and basic manual tests pass
- [ ] Outputs are auditable (explicit assumptions and computed values)
- [ ] No UI/I-O code added to core calculation modules

---

## 8) Suggested follow-ups (v0.9+)

- Detailed deflection method (long-term) as an opt-in path.
- Compliance checker integration once serviceability is stable.
- Shared test vectors for Python↔VBA parity harness.
