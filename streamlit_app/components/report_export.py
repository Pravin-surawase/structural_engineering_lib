# SPDX-License-Identifier: MIT
# Copyright (c) 2024-2026 Pravin Surawase
"""
Report Export Component for Streamlit UI
=========================================

Integrates TASK-277 (Calculation Reports) into Streamlit.
Allows users to export professional calculation sheets in HTML, JSON, or Markdown.

Usage:
    >>> from components.report_export import show_export_options
    >>> show_export_options(design_result, beam_id="B1")
"""

from __future__ import annotations

import json
import logging
from typing import Any

import streamlit as st

from structural_lib.audit import AuditTrail
from structural_lib.calculation_report import CalculationReport, ProjectInfo
from utils.session_manager import BeamInputs, DesignResult

logger = logging.getLogger(__name__)


# ============================================================================
# HELPER FUNCTIONS (defined first so scanner sees them before usage)
# ============================================================================


def _create_mock_library_result(result: DesignResult) -> Any:
    """Create a mock result object that matches library expectations.

    The CalculationReport.from_design_result expects certain attributes.
    We create a simple mock to bridge the gap.
    """

    class MockFlexure:
        def __init__(self, r: DesignResult) -> None:
            self.ast_required = r.ast_mm2
            self.ast_provided = r.ast_provided_mm2
            self.beam_type = (
                "singly reinforced" if r.ast_mm2 < 2000 else "doubly reinforced"
            )

    class MockShear:
        def __init__(self, r: DesignResult) -> None:
            self.vu_kn = r.inputs.vu_kn
            self.vc_kn = r.inputs.vu_kn * 0.6  # Approximate
            self.vs_kn = r.inputs.vu_kn * 0.4  # Approximate
            self.is_ok = r.status == "PASS"

    class MockDesign:
        def __init__(self, r: DesignResult) -> None:
            self.flexure = MockFlexure(r)
            self.shear = MockShear(r)

    class MockResult:
        def __init__(self, r: DesignResult) -> None:
            self.geometry = {
                "b_mm": r.inputs.b_mm,
                "D_mm": r.inputs.D_mm,
                "d_mm": r.inputs.d_mm,
                "span_mm": r.inputs.span_mm,
                "cover_mm": r.inputs.cover_mm,
            }
            self.materials = {
                "fck_nmm2": r.inputs.fck_mpa,
                "fy_nmm2": r.inputs.fy_mpa,
            }
            self.design = MockDesign(r)
            self.is_ok = r.status == "PASS"

        def summary(self) -> str:
            return f"Design {'passes' if self.is_ok else 'fails'} all IS 456 requirements."

    return MockResult(result)


def _generate_simple_report(
    result: DesignResult, beam_id: str, export_format: str
) -> tuple[str, str, str]:
    """Generate a simple report without library dependency."""
    if export_format == "json":
        content = json.dumps(result.to_dict(), indent=2)
        return content, f"report_{beam_id}.json", "application/json"

    # Simple markdown
    md = f"""# Calculation Report: {beam_id}

## Inputs
- Width: {result.inputs.b_mm} mm
- Depth: {result.inputs.D_mm} mm
- Moment: {result.inputs.mu_knm} kNÂ·m
- Shear: {result.inputs.vu_kn} kN

## Results
- Ast Required: {result.ast_mm2:.0f} mmÂ²
- Ast Provided: {result.ast_provided_mm2:.0f} mmÂ²
- Status: {result.status}

*Generated by structural-lib-is456 Streamlit*
"""
    return md, f"report_{beam_id}.md", "text/markdown"


def _generate_report(
    result: DesignResult,
    beam_id: str,
    story: str,
    project_name: str,
    engineer_name: str,
    export_format: str,
) -> tuple[str | bytes, str, str]:
    """Generate report content in specified format.

    Returns:
        Tuple of (content, filename, mime_type)
    """
    # Try professional report generation first
    try:
        # Create project info
        project_info = {
            "project_name": project_name,
            "engineer_name": engineer_name,
            "revision": "A",
        }

        # Create a mock result that CalculationReport expects
        mock_result = _create_mock_library_result(result)

        # Generate report
        report = CalculationReport.from_design_result(
            result=mock_result,
            beam_id=beam_id,
            story=story,
            project_info=project_info,
        )

        # Generate content based on format
        if export_format == "html":
            content = report._generate_html()
            filename = f"report_{beam_id}_{story}.html"
            mime_type = "text/html"
        elif export_format == "json":
            content = report.to_json()
            filename = f"report_{beam_id}_{story}.json"
            mime_type = "application/json"
        else:  # markdown
            content = report._generate_markdown()
            filename = f"report_{beam_id}_{story}.md"
            mime_type = "text/markdown"

        return content, filename, mime_type

    except Exception as e:
        # Fallback to simple report if library fails
        logger.warning(f"Professional report generation failed, using fallback: {e}")
        return _generate_simple_report(result, beam_id, export_format)


# ============================================================================
# PUBLIC FUNCTIONS
# ============================================================================


def show_export_options(
    result: DesignResult | None = None,
    beam_id: str = "B1",
    story: str = "GF",
    project_name: str = "",
    engineer_name: str = "",
) -> None:
    """Display export options for calculation reports.

    Args:
        result: Current design result (uses session state if None)
        beam_id: Beam identifier for report
        story: Story/floor identifier
        project_name: Project name for report header
        engineer_name: Engineer name for report
    """
    if result is None:
        result = st.session_state.get("current_result", None)

    if result is None:
        st.info("ğŸ’¡ Complete a design calculation to enable report export.")
        return

    st.subheader("ğŸ“„ Export Calculation Report")

    col1, col2 = st.columns([2, 1])

    with col1:
        # Project info inputs
        project = st.text_input(
            "Project Name",
            value=project_name if project_name else "Beam Design Project",
            key="export_project_name",
        )
        engineer = st.text_input(
            "Engineer Name",
            value=engineer_name,
            key="export_engineer_name",
        )

    with col2:
        # Format selection
        export_format = st.selectbox(
            "Export Format",
            options=["HTML", "JSON", "Markdown"],
            index=0,
            key="export_format",
        )

    # Export button
    if st.button("ğŸ”„ Generate Report", type="primary", key="generate_report_btn"):
        with st.spinner("Generating report..."):
            try:
                report_content, filename, mime_type = _generate_report(
                    result=result,
                    beam_id=beam_id,
                    story=story,
                    project_name=project,
                    engineer_name=engineer,
                    export_format=export_format.lower(),
                )

                # Store in session for download
                st.session_state["report_content"] = report_content
                st.session_state["report_filename"] = filename
                st.session_state["report_mime"] = mime_type

                st.success(f"âœ… Report generated: {filename}")

            except Exception as e:
                logger.exception("Report generation failed")
                st.error(f"âŒ Failed to generate report: {e}")

    # Download button (if report generated)
    if "report_content" in st.session_state:
        content = st.session_state.get("report_content", "")
        filename = st.session_state.get("report_filename", "report.txt")
        mime_type = st.session_state.get("report_mime", "text/plain")

        st.download_button(
            label="ğŸ“¥ Download Report",
            data=content,
            file_name=filename,
            mime=mime_type,
            key="download_report_btn",
        )

        # Preview for HTML
        if filename.endswith(".html"):
            with st.expander("ğŸ‘ï¸ Preview Report"):
                st.components.v1.html(content, height=600, scrolling=True)


def show_audit_trail_summary() -> None:
    """Display summary of audit trail for current session."""
    if "audit_trail" not in st.session_state:
        st.info("No audit trail for this session.")
        return

    trail: AuditTrail = st.session_state.get("audit_trail", None)
    if trail is None:
        st.info("No audit trail for this session.")
        return

    st.subheader("ğŸ” Audit Trail")

    if not trail.entries:
        st.info("No designs logged yet.")
        return

    # Summary stats
    col1, col2, col3 = st.columns(3)
    with col1:
        st.metric("Total Entries", len(trail.entries))
    with col2:
        beams = len(set(e.beam_id for e in trail.entries))
        st.metric("Unique Beams", beams)
    with col3:
        verified = sum(1 for e in trail.entries if e.action == "verify")
        st.metric("Verifications", verified)

    # Recent entries table
    with st.expander("ğŸ“‹ Recent Entries", expanded=False):
        for entry in reversed(trail.entries[-5:]):
            st.markdown(
                f"**{entry.entry_id}** | {entry.beam_id}@{entry.story} | "
                f"{entry.action} | {entry.timestamp[:19]}"
            )
            st.caption(f"Hash: {entry.hash.combined_hash[:24]}...")

    # Export audit log
    if st.button("ğŸ“¥ Export Audit Log", key="export_audit_btn"):
        content = trail.to_json()
        st.download_button(
            label="Download JSON",
            data=content,
            file_name=f"audit_trail_{trail.project_id}.json",
            mime="application/json",
            key="download_audit_btn",
        )
